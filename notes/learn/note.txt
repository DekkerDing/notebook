索引：
    创建索引
        PUT /es_index
    查询索引
        GET /es_index
        返回响应：
            别名 “aliases”： {}
            映射 “mappings”： {}
            settings {} 属性:
                索引名称 "provided_name": ""
                分片 "number_of_shards": ""
                    将一个物理大索引拆分成若干个小索引每一个小索引称为一个Shard
                    Index是逻辑概念，底层是若干个Shards，分布在若干节点上
                    个Shard最多可存放20亿个文档
                    查看:
                        GET /_cat/indices?v
                    设置参考
                        视情况定：节点数量 每个节点的容量 索引数量/大小 查询模式
                        业界推荐单个shard<=50GB
                        Github实践128个shards，每个120GB
                        作者推荐25G～40GB（考虑堆内存需求）
                        500GB数据->10~20个Shards
                        推荐每GB堆内存支持最多20个Shards
                        设置jvm.options（Xms/Xmx），ES缺省1GB
                        3 Shards+3Replicas/Shard，每个Shard50GB
                        Shards存储需求3x50GB=150GB
                        Replicas存储需求3x3x50GB=450GB

                副本 "numberofreplicas": ""
                    副本是分片的完全拷贝 也称replica shards
                    被复制的源Shard称为PrimaryShard
                    Primary Shard + Replica Shards统称Replication Group
                    查看
                        GET / cat/shards?v
                        GET / cluster/health
                    设置参考
                        关键业务：
                            2+
                        非关键业务：
                            1
                        auto_expand_replicas
                    快照：
                        快照用于对某个索引或者对整个集群进行备份
                uuid "uuid": ""
                版本 "version": {}
                分词器：
                    "index"：{
                        "analysis.analyzer.default.type"： "ik_max_word"
                    }
    索引是否存在
        HEAD /es_index
    删除索引
        DELETE /es_index
    关闭索引
        POST /es_index/close
    打开索引
        POST /es_index/_open
    重建索引
        POST _reindex

文档：
    添加文档：
        指定 ID：
            PUT /es_index/_doc/1
        自生成ID：
            POST /es_index/_doc
        共同点： 底层是先做删除后更新 形成一种覆盖的形式
        基于文档ID判断后添加 (保证文档唯一性)：
            PUT /es_index/create/1
            POST /es_index/create/1
        批量添加：
            创建 底层要基于文档ID校验： (如果文档存在则抛出异常)
                POST _bulk
                {
                    "create": {
                        "_index": "xxx对应索引",
                        "_type": "_doc",
                        "_id": xxx
                    }
                }
                {
                    "id":xxx,
                    添加数据....
                }
            创建 如文档存在覆盖原来文档：
                POST _bulk
                {
                    "index": {
                        "_index": "xxx对应索引",
                        "_type": "_doc",
                        "_id": xxx
                    }
                }
                {
                    "id":xxx,
                    添加数据....
                }

    更新文档：
        指定 ID：
            POST /es_index/_update/1
        基于查询条件更新： (类似于 Mysql Update xxx where xxx=xx )
            POST /es_index/_update_by_query
            {
                "query": {
                    "match":{
                        "_id": xx
                    }
                },
                "script": {
                    "source": "ctx._source.age = 30"
                }
            }

    查询文档：
            全文挡查询：
                GET /es_index/_search
            基于ID查询：
                GET /es_index/_doc/1

            match (全文检索)：
                要 分词 算分
                条件查询 or
                    GET /es_index/_search
                    {
                        "query":{
                            "match": {
                                "xxx字段": "xxx"
                            }
                        }
                    }

                条件查询 and
                    GET /es_index/_search
                    {
                        "query":{
                            "match": {
                                "xxx字段": {
                                    "query":  "xxx字段值",
                                    "operator": "and"
                                }
                            }
                        }
                    }

                查询条件 至少匹配(几个)
                    GET /es_index/_search
                    {
                        "query":{
                            "match": {
                                "xxx字段": {
                                    "query": "xxx字段值",
                                    "minimum_should_match": 2 至少匹配几个
                                }
                            }
                        }
                    }

                match_phrase 短语匹配 (对比 AND 更加精确 要求查询的分词与结果是连续的)：
                    GET /es_index/_search
                    {
                        "query":{
                            "match_phrase": {
                                "xxx字段": {
                                    "query": "xxx字段值" # 要求查询的分词与结果是连续的 (查询条件是什么查询结果就是什么)
                                    "slop": 2 # 指定中间可以隔多少个字符
                                }
                            }
                        }
                    }

                多条件字段查询:
                    GET /es_index/_search
                    {
                        "query":{
                            "multi_match": {
                                "query": "xxx字段值",
                                "fields": [
                                    "xxx条件字段",
                                    "xxx条件字段"
                                    ...
                                ]
                            }
                        }
                    }

                指定拼接查询条件查询 query_string:
                                允许我们在单个查询字符串中指定AND丨OR丨NOT条件同时也和multi_matchquery一样支持多字段搜索。
                                和match类似但是 match需要指定字段名query_string是在所有字段中搜索范围更广泛。
                                注意：查询字段分词就将查询条件分词查询查询字段不分词将查询条件不分词查询

                                指定单个查询字段范围：
                                    GET /es_index/_search
                                    {
                                        "query":{
                                            "query_string": {
                                                "default_field": "xxx字段" #指定字段查询范围 只搜索这个字段匹配的
                                                "query": "xxx字段值 AND xxx字段值"
                                            }
                                        }
                                    }
                指定多个查询字段范围：
                    GET /es_index/_search
                    {
                        "query":{
                            "query_string": {
                                "fields": [
                                "xxx字段", #指定字段查询范围 只搜索这个字段匹配的
                                "xxx字段"
                                ...
                                ]
                                "query": "xxx字段值 AND xxx字段值"
                            }
                        }
                    }

                简化 指定多个查询字段范围：
                    GET /es_index/_search
                    {
                        "query":{
                            "simple_query_string": {
                                "fields": [
                                "xxx字段", #指定字段查询范围 只搜索这个字段匹配的
                                "xxx字段"
                                ...
                                ]
                                "query": "xxx字段值",
                                default_operator: "AND" # 比较符号
                            }
                        }
                    }

                指定返回值:
                    GET /es_index/_search
                    {
                        "query":{
                            "match_all": {},
                            "_source": [
                                "字段名称",
                                ...
                            ]
                        }
                    }

            term：
            不分词 不算分
                精确查询 (如不进行分词)：
                    GET /es_index/_search
                    {
                        "query":{
                            "term": {
                                "FIELD": {
                                    "value": "xxx"
                                }
                            }
                        }
                    }
                精确查询 term
                查询字段映射类型为keyword
                    基于Query：
                        GET /es_index/_search
                        {
                            "query":{
                                "term": {
                                    "xxx字段.keyword": {
                                        "value": "xxx字段值"
                                    }
                                }
                            }
                        }
                    term 多值匹配
                        GET /es_index/_search
                        {
                            "query":{
                                "terms": {
                                    "xxx字段.keyword": [
                                        "xxx字段值"
                                            ...
                                        ]
                                    }
                                }
                            }
                        }

                    range 范围查找
                        range检索是Elasticsearch中一种针对指定字段值在给定范围内的文档的检索类型
                        这种查询适合对数字日期或其他可排序数据类型的字段进行范围筛选
                        range检索支持多种比较操作符，如大于(gt)、大于等于(gte)、小于(It)和小于等于(lte)等，可以实现灵活的区间查询

                        Elasticsearch支持日期数学表达式，允许在查询和聚合中使用相对时间点。以下是一些常见的日期数学表达式的示例和解释
                        now：当前时间点
                        now-1d：从当前时间点向前推1天的时间点
                        now-1w：从当前时间点向前推1周的时间点
                        now-1M：从当前时间点向前推1个月的时间点
                        now-1y：从当前时间点向前推1年的时间点
                        now+1h：从当前时间点向后推1小时的时间点

                        GET /es_index/_search
                        {
                            "query":{
                                "range": {
                                    "xxx字段": {
                                        "get": 25, # 大于
                                        "lte": 25, # 小于
                                        "lt": 25,
                                        "gt": 25,
                                        }
                                    }
                                }
                            }
                        }

                    exists 检查特定字段是否存在
                        GET /es_index/_search
                        {
                            "query":{
                                "exists": {
                                    "field": "xxx字段"
                                    }
                                }
                            }
                        }

                    基于多个ID查询
                        GET /es_index/_search
                        {
                            "query":{
                                "ids": {
                                    "values": [
                                            id,
                                            ...
                                        ]
                                    }
                                }
                            }
                        }

                    基于 constant_score：
                        GET /es_index/_search
                        {
                            "query":{
                                "constant_score": {
                                    "filter": {
                                        "term": {
                                            "xxx字段.keyword": "xxx字段值"
                                        }
                                    }
                                }
                            }
                        }
                前缀搜索 prefix:
                prefix会对分词后的term进行前缀搜索
                它不会对要搜索的字符串分词传入的前缀就是想要查找的前缀
                默认状态下前缀查询不做相关性分数计算它只是将所有匹配的文档返回然后赋予所有相关分数值为1
                它不会分析要搜索字符串传入的前缀就是想要查找的前缀
                默认状态下前缀查询不做相关度分数计算它只是将所有匹配的文档返回然后赋予所有相关分数值为1。
                它的行为更像是一个过滤器而不是查询。
                两者实际的区别就是过滤器是可以被缓存的而前缀查询不行。
                需要遍历所有倒排索引并比较每个词项是否以所搜索的前缀开头
                    GET /es_index/_search
                    {
                        "query":{
                            "prefix": {
                                "xxx字段.keyword": {
                                    "value": "xxx字段值"
                                }
                            }
                        }
                    }

                通配符查询 wildcard
                通配符查询可能会导致较高的计算负担因此在实际应用中应谨慎使用尤其是在涉及大量文档的情况下
                    GET /es_index/_search
                    {
                        "query":{
                            "wildcard": {
                                "xxx字段": {
                                    "value": "*xxx字段值*" # 如 *白*
                                }
                            }
                        }
                    }

                错误模糊冗余搜索 fuzzy
                    GET /es_index/_search
                    {
                        "query":{
                            "fuzzy": {
                                "xxx字段": {
                                    "value": "*xxx字段值"
                                    "fuzziness"： 2 # 冗余错误数量 AUTO
                                }
                            }
                        }
                    }

                terms_set 多值基于条件个数精确匹配
                    GET /es_index/_search
                    {
                        "query":{
                            "terms_set": {
                                "xxx字段": {
                                    "terms": [
                                        xxx字段值,
                                        ...
                                    ],
                                    "minimum_should_match_script"： {
                                        "source": "2" # 条件个数
                                    }
                                }
                            }
                        }
                    }

            批量查询：
                基于ID与不同索引查询：
                    GET _mget
                    {
                        "docs":[
                            {
                                "_index": "索引名称",
                                "_id": xxx
                            }
                            ...
                        ]
                    }

                基于多条件与不同索引查询：
                    GET /_msearch
                    {
                        "index": "xxx"
                    }
                    {
                        "query": {
                            "match_all": {}
                        },
                        "size": xxx,
                        "from": 0
                    }

            布尔查询 bool Query:
                一个bool查询是一个或者多个查询子句的组合总共包括4种子句其中2种会影响算分2种不影响算分
                must:相当于&&必须匹配贡献算分
                    可包含多个查询条件每个条件均满足的文档才能被搜索到每次查询需要计算相关度得分属于搜索上下文
                should:相当于|丨选择性匹配贡献算分
                    可包含多个查询条件不存在must和fiter条件时至少要满足多个查询条件中的一个文档才能被搜索到否则
                    需满足的条件数量不受限制，匹配到的查询越多相关度越高，也属于搜索上下文
                must_not:相当于！必须不能匹配不贡献算分
                    可包含多个过滤条件每个条件均满足的文档才能被搜索到每个过滤条件不计算相关度得分结果在一定条件下会被缓存属于过滤上下文
                filter:必须匹配不贡献算法
                    可包含多个过滤条件每个条件均不满足的文档才能被搜索到每个过滤条件不计算相关度得分结果在一定条件下会被缓存属于过滤上下文
                QueryContext:相关性算分
                FilterContext:不需要算分（Yes|No）,可以利用Cache获得更好的性能
                相关性并不只是全文本检索的专利也适用于yes丨no的子句匹配的子句越多相关性评分越高
                如果多条查询子句被合并为一条复合查询语句比如bool查询则每个查询子句计算得出的评分会被合并到总的相关性评分中

                布尔查询可以按照布尔逻辑条件组织多条查询语句只有符合整个布尔条件的文档才会被搜索出来

                搜索上下文(querycontext)：使用搜索上下文时Elasticsearch需要计算每个文档与搜索条件的相关度得分这个得分的计算
                需使用一套复杂的计算公式，有一定的性能开销，带文本分析的全文检索的查询语句很适合放在搜索上下文中

                过滤上下文（filtercontext)：使用过滤上下文时，Elasticsearch只需要判断搜索条件跟文档数据是否匹配，例如使用Term query判断一个值是否跟搜索内容一致
                使用Range query判断某数据是否位于某个区间等。
                过滤上下文的查询不需要进行相关度得分计算还可以使用缓存加快响应速度很多术语级查询语句都适合放在过滤上下文中

            分页查询:
                10000以内:
                    GET /es_index/_search
                    {
                        "query":{
                            "match_all": {},
                            "size": xxx,
                            "from": 0
                        }
                    }
                设置修改条数限制：
                    PUT /es_index/_settings
                    {
                        "index.max_result_window":"20000"
                    }
                快照 Scroll：
                    查询命令中新增scro11=1m说明采用游标查询保持游标查询窗口一分钟。
                    这里由于测试数据量不够所以size值设置为2
                    实际使用中为了减少游标查询的次数可以将值适当增大比如设置为1000
                    GET /es_index/_search?scroll=1m
                    {
                        "query": {
                            "match_all": {}
                        },
                        "size": xxx
                    }

                    scroll_id的值就是上一个请求中返回的_scroll_id的值
                    GET/_search/scroll
                    {
                        "scroll": "1m",
                        "scroll_id": "xxxx"
                    }
                排序：
                    GET /es_index/_search
                    {
                        "query":{
                            "match_all": {},
                            "sort": [
                                {
                                    "字段名称": "desc"
                                }
                            ]
                        }
                    }

    分词器：
        POST _analyze
        {
            "analyzer": "ik_max_word",
            "text": "值"
        }
    删除文档：
        基于ID删除:
            DELETE /es_index/_doc/1


别名:
    场景:
        跨多个索引数据统计
    POST /_aliases
    {
        "actions": [
            {
                "add": {
                    "index": "es_index",
                    "alias": "别名名称"
                }
            }
            ...
        ]
    }

相关性
    TF-IDF：

    BM25

索引模板：
    使用 索引创建设置组件化 基于索引模板前缀匹配,实现复用通用 索引 的 settings mappings
    索引模版只适用于新创建的索引
