多线程
    有了多线程我们就可以让程序同时做多件事情提高效率
    只要你想让多个事情同时运行就需要用到多线程
    比如：软件中的耗时操作、所有的聊天软件、所有的服务器
并发
    在同一时刻，有多个指令在单个CPU上交替执行
并行
    在同一时刻，有多个指令在多个CPU上同时执行
协程
    1.协程可以在一个线程内部创建多个协程，这些协程之间可以共享同一个线程的资源
    2.协程是在同一个进程内部运行的，不需要操作系统的介入，可以在用户空间内实现协作式多任务处理。
        因此协程的创建和销毁开销很小，可以更高效地利用系统资源。
    通俗角度：通俗地说，如果线程是饭店的饭桌协程就是座椅。

线程创建
    继承Thread类的方式进行实现
    实现Runnable接口的方式进行实现
    利用Callable接口和Future接口方式实现
    setDaemon() 设置为守护线程
        当其他的非守护线程执行完毕之后，守护线程会陆续结束
    yield() 出让线程/礼让线程
    join() 插入线程/插队线程
        表示把设置的这个线程，插入到当前线程之前
        当前： 看所执行的代码是运行在哪个线程上面的

synchronized:
    锁对象
        同步代码块
            基于 类 静态变量方式 static Object obj = new Object();
            this： 指的是当前执行代码的线程或者对象 (不推荐使用 this 因为它不是维护这同一个锁资源对象 无法实现锁机制)
            类名.class 指当前类 (推荐使用 能够基于JVM虚拟机 类加载特性 确保锁对象的唯一性)
        同步方法
            同步方法是锁住方法里面所有的代码
            锁对象不能自己指定
                非静态的方式  他的锁对象是 this 指的是当前执行代码的线程或者对象
                静态的方式 当前类的字节码文件对象 类名.class

等待/唤醒
    wait() 当前线程等待，直到被其他线程唤醒
    notify() 随机唤醒单个线程
    notifyAll() 唤醒所有线程
    阻塞队列
        ArrayBlockingQueue 底层是数组 有界
        LinkedBlockingQueue 底层是链表，无界但不是真正的无界最大为int的最大值

线程状态
    新建
        创建线程对象  Thread thread = new Thread()
    就绪
        等待 CPU 分配时间片 start()
    死亡
        run 方法执行完毕
    阻塞
        锁 阻塞
        程序操作运行阻塞
    等待/唤醒
        wait()
        notify()
        notifyAll()
    计时等待
        sleep()

线程池
    任务拒绝策略
        ThreadPoolExecutor.AbortPolicy
            默认策略： 丢弃任务并抛出RejectedExecutionException异常
        ThreadPoolExecutor.DiscardPolicy
            丢弃任务，但是不抛出异常这是不推荐的做法
        ThreadPoolExecutor.DiscardoldestPolicy
            抛弃队列中等待最久的任务然后把当前任务加入队列中
        ThreadPoolExecutor.CallerRunsPolicy
            调用任务的run()方法绕过线程池直接执行
    工作流程
        1. 当核心线程满时，再提交任务就会排队
        2. 当核心线程满，队列满时，会 查看设置的最大线程数 创建临时线程
        3. 当核心线程满，队列满，临时线程满时，会触发任务拒绝策略

CompletableFuture
    Completionstage 提供了更高级的功能和更好的可组合性。
    它是Java8中引l入的，作为java.util.con current 包的一部分。
    Completionstage 允许你以声明式的方式组合和链接异步操作，而不需要显式地处理回调函数。
    CompletableFuture的内部使用了基于ForkJoinPool的线程池，这种线程池可以高效地调度和执行任务。
    CompletableFuture的非阻塞特性得益于其对任务完成的监听机制。
    当任务完成时，它会遍历所有注册的回调函数，并在合适的线程中执行这些回调。
    通过这种机制，CompletableFuture能够在任务完成后及时返回结果或触发后续处理逻辑而不会阻塞主线程的执行。
    supplyAsync(Supplier<T> supplier)
        异步执行一个Supplier函数，并返回一个表示其结果的 CompletableFuture。
    runAsync(Runnable runnable)
        异步执行一个Runnable，不返回任何结果。
    thenAsync(Function<T, U> function)
        会利用CompletableFuture中公共的ForkJoinPool来执行任务
    thenApply(Function<T, U> function)
        当前Future 完成后，对其结果应用给定函数，并返回新的 CompletableFuture 有入参，有返回值
    thenAccept(consumer<T> action)
        当前 Future 完成后，对结果应用给定的 Consumer，不返回新值 有入参，无返回值
    thenRun(Runnable action)
        当前 Future 完成后，执行给定的 Runnable，不关心当前Future 的结果 无入参，无返回值
    thenCompose(Function<T, CompletableFuture< U>> function)
        当前Future 完成后，将结果传递给另一个 CompletableFuture 作为输入 有入参，有返回值，返回值类型只能是CompletionStage
        按顺序执行两个并行任务
    thenCombine CompletionStage<?extends U>other,BiFunction<?super T,?super U,?extendsV>fn
        第一个参数为CompletionStage
        第二个参数为具体要执行的任务，认为类型为BiFunction，有两个入参，一个返回值
        整合两个并行执行的任务结果
    runAfterEither
        两个任务中任意一个完成了，就执行回调
    runAfterBoth
        两个任务都完成了，才执行回调
    handle(BiFunction<T, Throwable, U> fn)
        处理当前Future 的结果或异常，并允许返回一个新结果。
    exceptionally(Function<Throwable, U> fn)
        指定当当前Future遇到异常时应采取的操作。
    complete(U value)
        显式地完成当前Future，设置其结果为给定值 直接让任务完成
    completeExceptionally(Throwable ex)
        显式地完成当前Future，设置其异常为给定异常。
    isDone()
        判断当前Future是否已完成。
    isCompletedExceptionally()
        判断当前Future是否因异常而完成。
    get()
        阻塞并等待当前Future 完成，然后返回结果。如果完成时出现异常，则抛出异常。
    get(long timeout, TimeUnit unit)
        在指定时间内阻塞并等待当前Future 完成，然后返回结果。如果超时或完成时出现异常，则抛出异常。
    T getNow(T valuelfAbsent)
        立即获取结果，如果任务还没完成，则返回valuelfAbsent
    whenComplete
        入参为BiConsumer<？superT,？superThrowable> action
        任务正常结束第一个参数传入的是结果
        任务异常结束第二个参数传入的是异常 异常类型是CompletionException
        没有返回值
    exceptionally
        入参为Function<Throwable，？extendsT> fn
        入参为异常 异常类型是CompletionException
        可以返回其他值
        如果任务没有出现异常则不会执行
    cancel
        如果任务还没开始，或正在执行，则能取消，设置取消标记为 true
        如果任务已经完成，则设置取消标记为 false
    allOf
        所有任务都执行完后才执行下一个任务
    anyOf
        任意一个任务执行完就可以执行下一个任务了

线程安全指的是
    我们写的某段代码在多个线程同时执行这段代码时，不会产生混乱
    依然能够得到正常的结果
    比如i++，初始化值为0，那么两个线程来同时执行这行代码，如果代码是线程安全的，那么最终的结果应该就是一个线程的结果为1
    一个线程的结果为2，如果出现了两个线程的结果都为1
    则表示这段代码是线程不安全的
    所以线程安全，主要指的是一段代码在多个线程同时执行的情况下，能否得到正确的结果