JDK
    Java标准开发包
    它提供了编译运行Java程序所需的各种工具和资源
    包括Java编译器
    Java运行时环境
    以及常用的Java类库等
JRE
    Java运行环境用于运行Java的字节码文件
JVM
    Java虚拟机是JRE的一部分
    它是整个java实现跨平台的最核心的部分负责运行字节码文件

hashCode 与 equals
    在Java中每个对象都可以调用自己的hashCode方法得到自己的哈希值（hashCode)
    相当于对象的指纹信息通常来说世界上没有完全相同的两个指纹
    但是在Java中做不到这么绝对
    但是我们仍然可以利用hashCode来做一些提前的判断
    比如如果两个对象的hashCode不相同那么这两个对象肯定不同的两个对象
    图如果两个对象的hashCode相同
    不代表这两个对象一定是同一个对象也可能是两个对象
    如果两个对象相等那么他们的hashCode就一定相同
    所以我们就需要注意如果我们重写了equals方法
    那么就要注意hashCode方法一定要保证能遵守上述规则
    减少hash冲突
    如果只重写
    equals方法，不重写hashCode方法
    就有可能导致 a.equals(b)这个表达式成立
    但是 hashCode却不同

String String Buffer String Builder
    String是不可变的如果尝试去修改会新生成一个字符串对象
    StringBuffer和StringBuilder是可变的
    StringBuffer是线程安全的
    StringBuilder是线程不安全的
    所以在单线程环境下StringBuilder效率会更高
== 与 equals
    ==如果是基本数据类型比较是值如果是引用类型比较的是引用地址
    equals具体看各个类重写equals方法之后的比较逻辑
    比如String类虽然是引用类型但是String类中重写了equals方法方法内部比较的是字符串中的各个字符是否全部相等

ApplicationContext和BeanFactory有什么区别
    BeanFactory是Spring中非常核心的组件表示Bean工厂
    可以生成Bean维护Bean而ApplicationContext继承了BeanFactory
    所以ApplicationContext拥有BeanFactory所有的特点也是一个Bean工厂
    但是ApplicationContext除开继承了BeanFactory之外
    还继承了诸如EnvironmentCapable、MessageSource、ApplicationEventPublisher 等接口
    从而ApplicationContext还有获取系统环境变量、国际化、事件发布等功能这是BeanFactory所不具备的

HashMap
    1.7
        1.7中底层是数组+链表
        1.7中链表插入使用的是头插法
        1.7中哈希算法比较复杂，存在各种右移与异或运算
    1.8
        1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率
        1.8中链表插入使用的是尾插法
        因为1.8中插入key和value时需要判断链表元素个数
        所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法
        1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率
        而1.8中新增了红黑树，所以可以适当的简化哈希算法
        节省CPU资源

HashMap Put操作
    先说HashMap的Put方法的大体流程：
    1.根据Key通过哈希算法与与运算得出数组下标
    2.如果数组下标位置元素为空，则将key和value封装为Entry对象
    （JDK1.7中是Entry对象，JDK1.8中是Node对象）并放入该位置
    3.如果数组下标位置元素不为空，则要分情况讨论
        a.如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中
        b.如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node
            如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中去
            在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value
            如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去
            因为是尾插法所以需要遍历链表
            在遍历链表的过程中会判断是否存在当前key，如果存在则更新value
            当遍历完链表后将新链表Node插入到链表中
            插入到链表后会看当前链表的节点个数如果大于等于8那么则会将该链表转成红黑树
            将key和value封装为Node插入到链表或红黑树中后
            再判断是否需要进行扩容如果需要就扩容
            如果不需要就结束PUT方法

HashMap的扩容机制原理
    1.7版本
        1.先生成新数组
        2.遍历老数组中的每个位置上的链表上的每个元素
        3.取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标
        4.将元素添加到新数组中去
        5.所有元素转移完了之后，将新数组赋值给HashMap对象的table属性
    1.8版本
        1.先生成新数组
        2.遍历老数组中的每个位置上的链表或红黑树
        3.如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去
        4.如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置
            a.统计每个下标位置的元素个数
            b.如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置
            c.如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置
        5.所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

ConcurrentHashMap
    1.7版本
        1.7版本的ConcurrentHashMap是基于Segment分段实现的
        2.每个Segment相对于一个小型的HashMap
        3.每个Segment内部会进行扩容，和HashMap的扩容逻辑类似
        4.先生成新的数组，然后转移元素到新数组中
        5.扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值
    1.8版本
        1.8版本的ConcurrentHashMap不再基于Segment实现
        2.当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容
        3.如果某个线程put时，发现没有正在进行扩容则将key-value添加到ConcurrentHashMap中
        然后判断是否超过阈值超过了则进行扩容
        4.ConcurrentHashMap是支持多个线程同时扩容的
        5.扩容之前也先生成一个新的数组
        6.在转移元素时，先将原数组分组
        将每组分给不同的线程来进行元素的转移
        每个线程负责一组或多组的元素转移工作

Java 死锁
    造成死锁的几个原因：
        1.一个资源每次只能被一个线程使用
        2.一个线程在阻塞等待某个资源时，不释放已占有资源
        3.一个线程已经获得的资源，在未使用完之前，不能被强行剥夺
        4.若干线程形成头尾相接的循环等待资源关系
    这是造成死锁必须要达到的4个条件
        如果要避免死锁只需要不满足其中某一个条件即可
        而其中前3个条件是作为锁要符合的条件
        所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系
    在开发过程中：
        1.要注意加锁顺序，保证每个线程按同样的顺序进行加锁
        2.要注意加锁时限，可以针对所设置一个超时时间
        3.要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决
        可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁

Java中的异常体系
    Java中的所有异常都来自顶级父类Throwable
    Throwable下有两个子类Exception和Error
    Error表示非常严重的错误，比如java.lang.StackOverFlowError和Java.lang.OutOfMemoryError，通常这些错误出现时
    仅仅想靠程序自己是解决不了的
    可能是虚拟机、磁盘、操作系统层面出现的问题了
    所以通常也不建议在代码中去捕获这些Error，因为捕获的意义不大，因为程序可能已经根本运行不了了
    Exception表示异常，表示程序出现Exception时，是可以靠程序自已来解决的
    比如NullPointerException、IllegalAccessException等，我们可以捕获这些异常来做特殊处理
    Exception的子类通常又可以分为RuntimeException和非RuntimeException两类
    RunTimeException表示运行期异常，表示这个异常是在代码运行过程中抛出的，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理
    这些异常一般是由程序逻辑错误引引起的，程序应该从逻辑角度尽可能避免这类异常的发生
    比如NullPointerException、IndexOutOfBoundsException等
    非RuntimeException表示非运行期异常，也就是我们常说的检查异常，是必须进行处理的异常
    如果不处理，程序就不能检查异常通过。如IOException、SQLException等以及用户自定义的Exception异常

Java类加载器
    JDK自带有三个类加载器：bootstrapClassLoader、ExtClassLoader、AppClassLoader
    BootStrapClassLoader是ExtClassLoader的父类加载器
    默认负责加载%JAVA_HOME%lib下的jar包和class文件
    ExtClassLoader是AppClassLoader的父类加载器负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和class类
    AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件.
类加载器双亲委派模型
    AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器是BootstrapClassLoader
    JVM在加载一个类时
    会调用AppClassLoader的loadClass方法来加载这个类
    不过在这个方法中，会先使用ExtClassLoader的loadClass方法来加载类
    同样ExtClassLoader的loadClass方法中会先使用BootstrapClassLoader来加载类
    如果BootstrapClassLoader加载到了就直接成功
    如果BootstrapClassLoader没有加载到，那么ExtClassLoader 就会自己尝试加载该类
    如果没有加载到，那么则会由AppClassLoader来加载这个类
    所以双亲委派指得是JVM在加载类时会委派给Ext和Bootstrap进行加载如果没加载到才由自己进行加载

JVM 垃圾回收算法
    1.标记清除算法：
        a.标记阶段：把垃圾内存标记出来
        b.清除阶段：直接将垃圾内存回收
        c.这种算法是比较简单的，但是有个很严重的问题，就是会产生大量的内存碎片
    2.复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法
        复制算法将内存分为大小相等的两半，每次只使用其中一半
        垃圾回收时，将当前这一块的存活对象全部拷贝到另一半
        然后当前这一半内存就可以直接清除
        这种算法没有内存碎片，但是他的问题就在于浪费空间
        而且他的效率跟存活对象的个数有关
    3.标记压缩算法：为了解决复制算法的缺陷，就提出了标记压缩算法
        这种算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后
        不是直接清理垃圾内存，而是将存活对象往一端移动然后将边界以外的所有内存直接清除
STW
    STW:Stop-The-World，是在垃圾回收算法执行过程当中，需要将JVM内存冻结的一种状态。
    在STW状态下，JAVA的所有线程都是停止执行的-GC线程除外
    native方法可以执行但是不能与JVM交互。
    GC各种算法优化的重点就是减少STW
    同时这也是JVM调优的重点
一个对象从加载到JVM，再到被GC清除，都经历了什么过程？
    1.首先把字节码文件内容加载到方法区
    2.然后再根据类信息在堆区创建对象
    3.对象首先会分配在堆区中年轻代的Eden区，经过一次MinorGC后，对象如果存活
        就会进入Suvivor区。
        在后续的每次MinorGC中，如果对象一直存活
        就会在 Suvivor区来回拷贝
        每移动一次，年龄加1
    4.当年龄超过15后，对象依然存活，对象就会进入老年代
    5.如果经过FulGC，被标记为垃圾对象，那么就会被GC线程清理掉
    而4个bt位能够存储的最大数值是15JVM分代年龄之所以设置成IS次
JVM参数
    JVM参数大致可以分为三类：
        1.标注指令：-开头，这些是所有的HotSpot都支持的参数。可以用java-help打印出来。
        2.非标准指令：-x开头，这些指令通常是跟特定的HotSpot版本对应的。可以用java-X打印出来。
        3.不稳定参数：-Xx开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大。
JVM 线程共享
    堆区和方法区是所有线程共享的
    栈、本地方法栈、程序计数器是每个线程独有的

Mybatis
    #
        #是预编译处理、是占位符
        Mybatis在处理#时会将sql中的#替换为？号，调用PreparedStatement来赋值；
        使用#可以有效的防止SQL注入，提高系统安全性。
    $
        $是字符串替换、是拼接符
        Mybatis在处理$时，会将sql中的$替换成变量的值，调用Statement来赋值；

CountDownLatch 和 Semaphore的区别和底层原理
    CountDownLatch表示计数器，可以给CountDownLatch设置一个数字
    一个线程调用CountDownLatch的await将会阻塞
    其他线程可以调用CountDownLatch的 countDown方法来对CountDownLatch中的数字减一
    当数字被减成0后所有await的线程都将被唤醒。
    对应的底层原理就是
        调用await方法的线程会利用AQS排队
        一旦数字被减为0则会将AQS中排队的线程依次唤醒。
    Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量
    通过acquire来获取许可
    如果没有许可可用则线程阻塞
    并通过AQS来排队可以通过release方法来释放许可
    当某个线程释放了某个许可后
    会从AQS中正在排队的第一个线程开始依次唤醒
    直到没有空闲许可。

Sychronized
    1.偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了
    2.轻量级锁：由偏向锁升级而来
        当一个线程获取到锁后，此时这把锁是偏向锁
        此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁
        之所以叫轻量级锁，是为了和重量级锁区分开来
        轻量级锁底层是通过自旋来实现的并不会阻塞线程
    3.如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞
    4.自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程
    也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间
    自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取
    如果获取到了则表示获取到了锁
    这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。

ReentrantLock
    1.tryLock表示尝试加锁，可能加到，也可能加不到，该方法不会阻塞线程，如果加到锁则返回true，没有加到则返回false
    2.lock表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值

ReentrantLock 公平锁 非公平锁
    首先不管是公平锁和非公平锁，它们的底层实现都会使用AQS来进行排队，
    它们的区别在于：线程在使用lock方法加锁时
        如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队
        如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁。
    不管是公平锁还是非公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程
    所以非公平锁只是体现在了线程加锁阶段
    而没有体现在线程被唤醒阶段。
    ReentrantLock是可重入锁，不管是公平锁还是非公平锁都是可重入的。

Sychronized和ReentrantLock的区别
    1.sychronized是一个关键字，ReentrantLock是一个类
    2.sychronized会自动的加锁与释放锁，ReentrantLock需要程序员手动加锁与释放锁
    3.sychronized的底层是JVM层面的锁，ReentrantLock是APi层面的锁
    4.sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁
    5.sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态
    6.sychronized底层有一个锁升级的过程
    7. sychronized锁释放是被动的 synchronized只有代码块执行结束 代码执行出现异常的时候 才会去释放锁

谈谈你对AQS的理解，AQS如何实现可重入锁？
    1 AQS是一个JAVA线程同步的框架。是JDK中很多锁工具的核心实现框架。
    2.在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。
        其中，这个线程队列，就是用来给线程排队的
        而state就像是一个红绿灯，用来控制线程排队或者放行的。
        在不同的场景下，有不用的意义。
    3.在可重入锁这个场景下
        state就用来表示加锁的次数。
        0标识无锁，每加一次锁，state就加1。
        释放锁state就减1。

TCP的三次握手和四次挥手
    TCP协议是7层网络协议中的传输层协议负责数据的可靠传输。
    在建立TCP连接时，需要通过三次握手来建立
    过程是：
        1.客户端向服务端发送一个SYN
        2.服务端接收到SYN后，给客户端发送一个SYN_ACK
        3.客户端接收到SYN_ACK后，再给服务端发送一个ACK
    在断开TCP连接时，需要通过四次挥手来断开
    过程是：
        1.客户端向服务端发送FIN
        2.服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理
        3.服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接
        4.客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了

浏览器发出一个请求到收到响应经历了哪些步骤？
    1.浏览器解析用户输入的URL，生成一个HTTP格式的请求
    2.先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址
    3.浏览器通过操作系统将请求通过四层网络协议发送出去
    4.途中可能会经过各种路由器、交换机，最终到达服务器
    5.服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了
    6.tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet
    7.然后servlet来处理这个请求，如果是SpringMVC中的DispatcherServlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果
    8.Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器
    9.浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染

ThreadLocal的底层原理
    1.ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据
    2.ThreadLocal底层是通过ThreadLocalMap来实现的
        每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap
        Map的key为ThreadLocal对象，Map 的value为需要缓存的值
    3.如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key，value，也就是Entry对象进行回收
    但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap
    ThreadLocalMap也是通过强引I用指向Entry对象
    线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏
    解决办法是，在使用了ThreadLocal对象之后
        手动调用ThreadLocal的remove方法，手动清楚Entry对象
    4.ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接）

线程池的底层工作原理
    线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时：
    1.如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。
    2.如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列
    3.如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满
        并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。
    4.如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满
        并且线程池中的数量等于maximumPoolSize，那么通过handler所指定的策略来处理此任务。
    5.当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。
        这样，线程池可以动态的调整池中的线程数
线程池为什么是先添加列队而不是先创建最大线程？
    当线程池中的核心线程都在忙时
    如果继续往线程池中添加任务
    那么任务会先放入队列，队列满了之后，才会新开线程。
    这就相当于
        一个公司本来有10个程序员
        本来这10个程序员能正常的处理各种需求
        但是随着公司的发展需求在慢慢的增加
        但是一开始这些需求只会增加在待开发列表中
        然后这10个程序员加班加点的从待开发列表中获取需求并进行处理但是某一天待开发列表满了
        公司发现现有的10个程序员是真的处理不过来了
        所以就开始新招员工了
    线程池初始化
        向线程池里面添加任务的时候被动初始化
        主动调用 prestartAllCoreThreads方法


volatile
    1 可以保证在多线程环境下共享变量的可见性
    2 通过增加内存屏障防止多个指令之间的重排序

可重入
    简单来说呢就是说在运行的某个函数或者代码因为抢占资源或者中断导致这个函数或者代码运行过程中被中断了
    那么等到中断的程序执行结束以后重新进入到这个函数的代码里面再运行的时候并且运行的结果不会发生变化
    那么这个函数或者代码就是可重入的

    简单来说就是说一个线程如果抢占到了互房锁的资源在锁释放之前再去竞争同一把锁的时候不需要等待只需要去记录重入次数

强引用 软引用 弱引用 虚引用
    主要体现的是对象不同的可达性状态和对于垃圾收集的影纫响
    强引用就是普通对象的一尔弓用
    弱引用 只有当JVM认为内存不足的时候才会去试图回收引用指向的对象
    虚引用 它不会决定对象的生命周期它提供一种确保对象被finalize以后去做某些事情的一种机制
        就会在回收对象的内存之前啊

finally语句块在两种情况下不会执行
    1、程序没有进入到try语句块因为异常导致程序终止，这个问题主要是开发人员在编写代码的时候，异常捕获的范围不够
    2、在try或者cache语句块中，执行了System.exit（O）语句，导致JVM直接退出

SPI
    机制的主要思想呢是把装配的控制权转移到了程序之外完成标准和实现的一个解耦
    以及提供一个动态可插拔的扩展能力
    1. 需要先定义一个接口作为扩展的标准
    2. 在classpath目录下创建META-INF/service文件目录
        在这个目录下以接口的全限定名命名的配置文件文件内容是这个接口的实现类
    3. 在应用程序里面，使用ServiceLoad根据接口名称找到classpath所有的扩展时间

HashTable
    基于hash表实现的 K-V结构的集合线程安全的集合类基于 Synchronized同步锁 数组+链表
    HashMap可以使用null作为key而Hashtable不允许

SortedSet
    有序集合
    不允许元素有重复
    按照元素的自然顺序或者自定文比较器进行排序
    元素的添加和删除操作的时间复杂度为O(logn)

如何破坏双亲委派模型
    重写ClassLoader里面的loadclassl方法
    使用findClass方法
    使用线程上下文加载器

类加载