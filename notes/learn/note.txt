DDL

DML

DCL

视图

存储过程函数

变量

流程控制 游标

触发器

窗口函数

公用表达式

约束

SELECT
    执行过程
    排序分页
    聚合函数
    子查询
    运算符

锁
    全局锁
        它会阻止其他所有的数据修改操作
        FLUSHTABLESWITHREADLOCK（FTWRL）语句来添加全局读 这将阻止其他线程进行更新操作
        使用UNLOCKTABLES语句来释放锁定
    表锁
        每次操作锁住整张表。表锁虽然操作简单，加锁快，但并发度低，因为会锁住整张表，在高并发场景下可能会导致其他事务长时间等待
        Lock TABLES employee read;
        unlock tables;
    页锁
        在页的粒度上进行锁定。页锁则介于两者之间，综合了表锁和行锁的部分特点
    行锁
        行级锁只在事务中有效
    间隙锁
        间隙锁”(Gap Lock)间隙锁不仅锁定一个具体的行还锁定它前后的“间隙 防止其他事务插入新的行到已锁定行的前后
        间隙锁：（InnoDB）锁的是两个值之间的空隙，在可重复读隔离级别下生效。
        MvSQL默认级别是repeatable－read，存在幻读问题，间隙锁可解决此问题。
    意向锁
        SELECT * FRoM performance_schema.data_locks; 查看锁状态
            engine 使用的引擎
            engine_lock_id 锁的ID
            object_name 锁的对象名称
            index_name 锁的索引名称
            lock_mode 锁模式
            lock_type 锁类型
            lock_status 锁状态
            lock_data 锁数据
        意向共享锁
            共享锁（S锁）：共享锁也称为读锁它允许一个事务读取一行数据其他事务可以读取这行数据但不能对其进行修改
            SELECT..LOCKINSHAREMODE：这种查询会对选定的行添加一个共享锁（S锁）
        意向排他锁
            排他锁（X锁》：排他锁也称为写锁它允许一个事务读取和修改一行数据其他事务不能读取也不能修改这行数据
            SELECT.FORUPDATE：这种查询会对选定的行添加一个排他锁（X锁）
    MVCC
        在MySQL InnoDB存储引|擎下 RC、RR基于MVCC（多版本并发控制）进行并发事务控制MVCC是基于”数据版本”对并发事务进行访问
            trx_id 事务编号 (自增)
            UNDO_LOG 版本链
                UNDOLOG不是会被册除吗?中间数据万一被删了版本链不就断了？
                UNDOLOG版本链不是立即册除MySQL确保版本链数据不再被“引|用"后再进行删除
                DB_ROLL_PTR 指向上一次版本变化 事务信息
            ReadView 快照视图
                快照读
                    ReadView是“快照读”SQL执行时MVCC提取数据的依据快照读就是最普通的 Select 查询SQL语句
                当前读
                    当前读指代执行下列语句时进行数据读取的方式
                    Insert、Update、Delete. Select...for update Select...lock in share mode
                m_ids
                    当前活跃的事务编号集合(未提交得事务id集合)
                min_trx_id
                    最小活跃事务编号
                max_trx_id
                    预分配事务编号，当前最大事务编号+1
                creator_trx_id
                    ReadView创建者的事务编号
                读已提交（RC）
                    在每一次执行快照读时生成 ReadView
                可重复读（RR）
                    仅在第一次执行快照读时生成 ReadView，后续快照读复用
                    连续多次快照读，ReadView会产生复用，没有幻读问题
                    特例
                        当两次快照读之间 存在 当前读，ReadView 会重新生成，导致产生幻读
                版本链数据访问规则：
                    判断当前事务id等于creator_trxid 创建者id吗？成立说明数据就是自己这个事务更改的，可以访问
                    判断当前事务id小于trxid<mintrxid 最小得事务编号吗？成立说明数据已经提交了，可以访问
                    判断trx_id>max_trx_id最大事务编号？成立说明该事务是在ReadView生成以后才开启，不允许访问
                    判断min_trx_id最小得事务id<=trx_id(判断是否在这个范围中)<=max_trx_id最大事务id
                    成立在m_ids(这个是未提交得事务id集合)数据中对比，不存数据在的则代表数据是已提交的，可以访问。
    乐观锁
        基于版本号程序控制数据修改粒度
    死锁
    临键锁
        临键锁(Next-keyLocks)：（lonoDB）Next-KeyLocks是行锁与间隙锁的组合
        Next-Key可以理解为一种特殊的间隙锁据行的临键锁时会锁住一段左开右闭区间的数据 通过临建锁可以解决幻读的问题
        临键锁只与非唯一索引列有关在唯一索引列（包括主键列）上不存在临键锁

    记录锁
        记录锁（RecordLock）是MySQL数据库中InnoDB存储引l擎的一种锁定机制主要用于锁定
        和控制对单个行记录的访问。记录锁是在索引记录上设置的对于表没有主键或唯一索引的表
        InnoDB会自动为每一行生成一个隐藏的聚集索引并在这个隐藏索引[上加锁
        是行锁得一种实现
        是ImnoDB存储引擎实现的一种行级锁，它直接作用于索引记录。
        当事务需要对某条数据进行操作时，会对该数据对应的索引记录加上锁，以此来控制并发访问，保证数据的一致性和完整性。
        注意事项：InnoDB的行锁是针对索引加锁（在对应的索引项上做标记）
        且索引不能失效，否则会从行锁升级为（假）表锁（RR级别会升级为表锁，RC级别不会升级为表锁）
        例如在RR级别执行：select * from xxx where name='小明’ for update；（where条件里的name字段无索引）
        其它Session对该表任意一行记录做修改操作都会被阻塞。
        RR（可重复读）级别
            由于RR级别通过间隙锁（GapLocks）防止幻读，全表扫描会导致所有扫描过的行（包括不满足条件的行）被加上行锁同时所有间隙被加上间隙锁
            这会锁定整个表的记录和间隙，其他会话对该表的任意修改（增、删、改）操作都会被阻塞，效果等同于表锁，但机制上仍为行锁和间隙锁的组合
        RC（读已提交）级别
            RC级别不启用间隙锁，且仅锁定实际满足条件的行。虽然全表扫描会逐行检查，但最终仅对符合条件的行加锁
            不符合条件的行在检查后立即释放锁因此，其他会话可以修改未被锁定的行，不会升级为表锁
    读锁
        它阻止其他用户更新数据但允许他们读取数据
    写锁
        它阻止其他用户读取或写入数据但允许他们更新数据