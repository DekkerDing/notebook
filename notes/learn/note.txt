DDL

DML

DCL

视图

存储过程函数

变量

流程控制 游标

触发器

窗口函数

公用表达式

约束

SELECT
    执行过程
    排序分页
    聚合函数
    子查询
    运算符

B树 与 B+树
    B树的特点：
        1.节点排序
        2.一个节点了可以存多个元素多个元素也排序了
    B+树的特点：
        在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上(链表上)，而非叶子节点上只存储key值
        这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
        1.拥有B树的特点
        2.叶子节点之间有指针
        3.非叶子节点上的元素在叶子节点上都冗余了也就是叶子节点中存储了所有的元素并且排好顺序
    Mysq索引使用的是B+树
        因为索引是用来加快查询的而B+树 通过对数据进行排序所以是可以提高查询速度的然后通过一个节点中可以存储多个元素
        从而可以使得 B+树的高度不会太高
        B+树 最顶层非叶子节点是常驻内存 IO
        在Mysql中一个Innodb页就是一个B+树节点
        一个Innodb页默认16kb
        所以一般情况下一颗两层的B+树可以存2000万行左右的数据
        然后通过利用B+树叶子节点 存储了所有数据并且进行了排序 并且叶子节点之间有指针
        可以很好的支持全表扫描范围查找等SQL语句

慢查询
    1.检查是否走了索引|，如果没有则优化SQL利用索引
    2.检查所利用的索引，是否是最优索引
    3.检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据
    4.检查表中数据是否过多，是否应该进行分库分表了
    5.检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源

索引
    1.适合索引的列是出现在where子句中的列，或者连接子句中指定的列
    2.基数较小的表，索引效果较差，没有必要在此列建立索引
    3.使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
        如果搜索词超过索引前缀长度
        则使用索引排除不匹配的行
        然后检查其余行是否可能匹配。
    4.不要过度索引。
        索引需要额外的磁盘空间，并降低写操作的性能。
        在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。
        所以只保持需要的索引有利于查询即可。
    5.定义有外键的数据列一定要建立索引。
    6.更新频繁字段不适合创建索引
    7.若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）
    索引缺点
        1、维护索引需要耗费数据库资源
        2、索引需要占用磁盘空间
        3、当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响

索引覆盖是什么
    索引覆盖就是一个SQL在执行时，可以利用索引来快速查找，
    并且此SQL所要查询的字段在当前索引对应的字段中都包含了，
    那么就表示此SQL走完索引后不用回表了，
    所需要的字段都在当前索引的叶子节点上存在，
    可以直接作为结果返回了

最左前缀原则是什么
    当一个SQL想要利用索引时就一定要提供该索引所对应的字段中最左边的字段
    也就是排在最前面的字段
    比如针对a,b,c三个字段建立了一个联合索引
    那么在写一个sql时就一定要提供a字段的条件
    这样才能用到联合索引
    这是由于在建立a,b，c三个字段的联合索引时
    底层的B+树是按照a,b,c三个字段从左往右去比较大小进行排序的
    所以如果想要利用B+树进行快速查找也得符合这个规则

InnoDB如何解决幻读这个问题
    行锁
    间隙锁

binlog redolog undolog relaylog
    binlog
        二进制日志（Binlog）主要用于记录所有针对数据库表结构的变更以及表数据的修改操作
        但不包括如 SELECT、SHOW等读取类的操作。
        Binlog是在事务成功提交后，在服务层生成的日志文件，其主要功能体现在两个方面：
            1。数据恢复：
                通过详尽地记录所有影响数据状态的SQL命令，Binlog为从特定时间点或由于意外操作导致的数据丢失提供了恢复手段。
                一旦发生数据损坏或丢失事件，可以通过重放Binlog中的历史更改来恢复至先前的状态。
            2.主从复制：
                对于需要跨多台服务器实现数据备份的应用场景，可以利用监听写入数据库的Binlog日志机制
                将主数据库的所有更新同步到一个或多个从属数据库上，从而构建出高效的分布式数据库架构。
        其中binlog主要用来做数据备份
        记录数据库的逻辑变化
        statement
            STATEMENT模式：在此模式下
                每一条引起数据变化的SQL语句都会被直接记录下来。
                这种方式的优点在于减少了日志大小并提高了处理速度；
                然而，如果使用了SYSDATE（）、NOW（）之类的非确定性函数，则可能导致在执行数据恢复或主从复制过程中产生一致性问题。
        row
            ROW模式：
                与记录整个SQL不同，ROW模式仅追踪实际受到影响的数据行的变化情况。
                这种方法避免了STATEMENT模式下的动态内容带来的挑战，但代价是增加了日志文件的体积。
        mixed
            MIXED模式：
                作为前两者的折中方案，MIXED模式根据具体情况自动选择最合适的记录方式。
                当系统认为STATEMENT更优时采用之，否则切换到ROW模式以确保准确性。
                需要注意的是，默认的Binlog格式设置取决于所使用的MySQL版本：5.7.7以前默认为STATEMENT，之后改为ROW。用户可以通过调整binlog-format参数来自定义所需的行为。
    redolog
        在InnoDB存储引擎中，大部分RedoLog记录的是物理日志，即对特定数据页所进行的具体修改。
        那么，为何称其为“大部分”是物理日志呢？这主要是因为RedoLog系统由两大部分构成：
            一是位于内存中的重做日志缓冲区（RedoLogbuffer），这部分信息容易因断电等原因丢失;
            二是保存于磁盘上的重做日志文件（RedoLog file），提供持久化存储。
        可以通过RedoLog来恢复未完成的数据，保证数据的完整性
        RedoLog可以把未提交的事务回滚，把已提交的事务进行持久化
        尽管bufferpool确实极大地提升了数据库操作的性能，但由于其基于内存的特点，存在着固有的不稳定性
        一旦遇到如电力中断等意外情况，未及时写入磁盘的数据（脏页）可能会永久丢失。
        正是为了解决这一问题，RedoLog机制被设计出来。
        通过与buffer pool及changebuffer协同工作，RedoLog负责记录所有尚未同步至磁盘的更改操作
        确保即使发生故障重启后也能恢复这些更新，直至相关页面最终被安全地写入磁盘为止。
        这样做的目的是为了实现【数据持久化】，保障事务处理过程中的持久性特征不受影响。
        缓冲池(bufferpool）的主要功能在于缓存来自磁盘的数据页，以此减少频繁访问磁盘造成的l/O开销。
        变更缓冲(changebuffer）则用于暂时存放那些尚未加载到缓冲池中的待更新数据项，直到需要时才将其读入并执行相应的更新动作，之后再由后台进程异步刷新至磁盘上。
        RedoLog与undolog之间的差异
            RedoLog专注于记录事务完成后的新状态，即变更后的值；
            UndoLog则用来追踪事务开始前的原始状态，保存的是变更前的l旧值。
    undolog 回滚日志
        回滚日志（Undo Log）是数据库引擎层生成的一种日志
        主要用于确保事务的ACID特性中的原子性（Atomicity）
        它记录的是逻辑操作 即数据在被修改之前的状态
        这些逻辑操作包括
        插入（INSERT）
            INSERT操作：在undolog中记录新插入记录的主键ID。如果事务需要回滚，则根据该主键ID删除对应的记录。
        更新（UPDATE）
            UPDATE 操作：对于每次更新操作，会记录一条与之相反的undo log条目。
            例如，如果原始操作是将某个字段从A更新为 B，则undo log将记录一个从B更新回A的操作。
            这样，在事务回滚时可以通过执行这些逆向更新来恢复原值。
        删除（DELETE）
            DELETE 操作：在执行删除之前，undolog会保存即将被删除的数据副本。
            如果发生回滚，则重新插入这些已删除的数据。通过上述机制，即使在事务处理过程中出现错误，也可以确保数据库能够恢复至一致且正确的状态。
        1.事务回滚：当事务需要回滚时，通过执行undolog中记录的逆向操作来恢复到事务开始前的数据状态。
        2.多版本并发控制（MVcC)：结合ReadView机制，利用undolog实现多版本并发控制，从而支持高并发读写操作。
    relaylog

运维
    通过show processlist 去查询当前的会话情况确定是否有消耗资源的SQL正在运行

索引失效
    最左匹配原则
    索引列使用不等于号或not查询时
    使用like通配符匹配后缀时
    使用or连接查询时 只有OP左右查询字段都使用索弓列的时候呢才会生效

聚簇索引 非聚簇索引
    设定为主键后数据库会自动建立索引，innodb为聚索引主键索引索引列值不能有空
    聚簇索引
        将数据存储与素引放到了一块，索引结构的叶子节点保存了行数据
    非聚族索引
        将数据与素引分开存储，索引结构的叶子节点指向了数据对应的位置

唯一索引
    索引列的值必须唯一，但允许有空值

树结构
    二叉树

    红黑树

    B树

事务
    优化原则
        在保证业务逻辑的前提下，尽可能缩短事务长度
        大事务拆分为小事务
        DDL拆分（无锁变更）
        长事务合并为大事务
        长事务分解（不必要的请求摘除）
        应用侧保证一致性
脏页

优化
    尽量避免使用SELECT*，只查询需要的列。
    使用JOIN代替子查询，减少嵌套查询的层次。
    避免在WHERE子句中使用ILIKE‘%value%'，这会导致全表扫描。
    合理使用LIMIT子句，限制查询结果的数量。
    将表中不常用的字段或大型字段（如TEXT、BLOB）分离到单独的表中
    定期将不常用的日数据归档到历史表中，减少主表的数据量

Explain
    表的读取顺序
    SQL执行时查询操作类型
    可以使用哪些索引实际使用哪些索引
    每张表有多少行记录被扫描

    id 每个select都有一个对应的id号，并且是从1开始自增的
    select_type 查询语句执行的查询操作类型
    table 表名
    partitions 表分区情况
    type 查询所用的访问类型
        system > const > eq_ref > ref > fulltext > ref_or_null > range > index > ALL
        一般来说保证 range 级别，最好能达到 ref 级别。
        system：const类型的一种特殊场景，查询的表只有一行记录的情况，并且该表使用的存储引擎的统计数据是精确的
        const：基于主键或唯一索引查看一行，当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问转换成常量查询，效率高
        eq_ref：基于主键或唯一索引连接两个表，对于每个索引键值，只有一条匹配记录，被驱动表的类型为'eq_ref
        ref：基于非唯一索引连接两个表或通过二级索引列与常量进行等值匹配，可能会存在多条匹配记录
        range：使用非唯一索引l扫描部分索引l，比如使用索引获取某些范围区间的记录
        index：扫描整个索引就能拿到结果，一般是二级索引，这种查询一般为使用覆盖索引（需优化，缩小数据范围）
        NULL：MySQL在优化过程中分解语句就已经可以获取到结果，执行时甚至不用访问表或索引1。
    possible_keys 可能用到的索引
    key 实际查询用到的索引
    key_len 所使用到的索引长度 索引长度
    ref 使用到索引时，与索引进行等值匹配的列或者常量
        ref例：表示将哪个字段或常量和key列所使用的字段进行比较。
        当使用索引列等值查询时，与索引列进行等值匹配的对象信息。
    rows 预计扫描的行数（索引行数或者表记录行数）
        全表扫描时表示需要扫描表的行数估计值；索引扫描时表示扫描索引的行数估计值：值越小越好（不是结果集中的行数）
    filtered 表示符合查询条件的数据百分比
        表示符合查询条件的数据百分比。可以使用rows*filtered/100计算出与explain前一个表进行连接的行数。
    Extra SQL执行的额外信息

脏页 check point
    脏页现象： Mysql 内存占存的数据与磁盘比较不一致
    什么时候触发checkpoint：
        masterthread：每一秒或者每十秒刷写脏页
        bufferpool；innodb_Iru_scan_depth|1024；如果低于指定空闲页，将触发checkpoint。
        重做日志不可用，将触发checkpoint
        buffer pool；innodb_max_dirty_pages_pct丨75.000000；如果超过指定75%，将触发checkpoint。
        innodb_fast_shutdown|1；如果关闭数据库将bufferpool中所有的脏页全部刷写到磁盘