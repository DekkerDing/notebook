DDL

DML

DCL

视图

存储过程函数

变量

流程控制 游标

触发器

窗口函数

公用表达式

约束

SELECT
    执行过程
    排序分页
    聚合函数
    子查询
    运算符

B树 与 B+树
    B树的特点：
        1.节点排序
        2.一个节点了可以存多个元素多个元素也排序了
    B+树的特点：
        在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上(链表上)，而非叶子节点上只存储key值
        这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
        1.拥有B树的特点
        2.叶子节点之间有指针
        3.非叶子节点上的元素在叶子节点上都冗余了也就是叶子节点中存储了所有的元素并且排好顺序
    Mysq索引使用的是B+树
        因为索引是用来加快查询的而B+树 通过对数据进行排序所以是可以提高查询速度的然后通过一个节点中可以存储多个元素
        从而可以使得 B+树的高度不会太高
        B+树 最顶层非叶子节点是常驻内存 IO
        在Mysql中一个Innodb页就是一个B+树节点
        一个Innodb页默认16kb
        所以一般情况下一颗两层的B+树可以存2000万行左右的数据
        然后通过利用B+树叶子节点 存储了所有数据并且进行了排序 并且叶子节点之间有指针
        可以很好的支持全表扫描范围查找等SQL语句

慢查询
    1.检查是否走了索引|，如果没有则优化SQL利用索引
    2.检查所利用的索引，是否是最优索引
    3.检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据
    4.检查表中数据是否过多，是否应该进行分库分表了
    5.检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源

索引
    1.适合索引的列是出现在where子句中的列，或者连接子句中指定的列
    2.基数较小的表，索引效果较差，没有必要在此列建立索引
    3.使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
        如果搜索词超过索引前缀长度
        则使用索引排除不匹配的行
        然后检查其余行是否可能匹配。
    4.不要过度索引。
        索引需要额外的磁盘空间，并降低写操作的性能。
        在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。
        所以只保持需要的索引有利于查询即可。
    5.定义有外键的数据列一定要建立索引。
    6.更新频繁字段不适合创建索引
    7.若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）
    索引缺点
        1、维护索引需要耗费数据库资源
        2、索引需要占用磁盘空间
        3、当对表的数据进行增删改的时候，因为要维护索引，速度会受到影响

索引覆盖是什么
    索引覆盖就是一个SQL在执行时，可以利用索引来快速查找，
    并且此SQL所要查询的字段在当前索引对应的字段中都包含了，
    那么就表示此SQL走完索引后不用回表了，
    所需要的字段都在当前索引的叶子节点上存在，
    可以直接作为结果返回了

最左前缀原则是什么
    当一个SQL想要利用索引时就一定要提供该索引所对应的字段中最左边的字段
    也就是排在最前面的字段
    比如针对a,b,c三个字段建立了一个联合索引
    那么在写一个sql时就一定要提供a字段的条件
    这样才能用到联合索引
    这是由于在建立a,b，c三个字段的联合索引时
    底层的B+树是按照a,b,c三个字段从左往右去比较大小进行排序的
    所以如果想要利用B+树进行快速查找也得符合这个规则

InnoDB如何解决幻读这个问题
    行锁
    间隙锁

binlog 和 redolog
    其中binlog主要用来做数据备份
    记录数据库的逻辑变化
    statement
    row
    mixed
    redolog
        主要是在Mysql数据库事务的ACID特性里面，用来保证数据的持久化特性
        可以通过RedoLog来恢复未完成的数据，保证数据的完整性
        RedoLog可以把未提交的事务回滚，把已提交的事务进行持久化
运维
    通过show processlist 去查询当前的会话情况确定是否有消耗资源的SQL正在运行

索引失效
    最左匹配原则
    索引列使用不等于号或not查询时
    使用like通配符匹配后缀时
    使用or连接查询时 只有OP左右查询字段都使用索弓列的时候呢才会生效

聚簇索引 非聚簇索引
    设定为主键后数据库会自动建立索引，innodb为聚索引主键索引索引列值不能有空
    聚簇索引
        将数据存储与素引放到了一块，索引结构的叶子节点保存了行数据
    非聚族索引
        将数据与素引分开存储，索引结构的叶子节点指向了数据对应的位置

唯一索引
    索引列的值必须唯一，但允许有空值

树结构
    二叉树

    红黑树

    B树

事务
    优化原则
        在保证业务逻辑的前提下，尽可能缩短事务长度
        大事务拆分为小事务
        DDL拆分（无锁变更）
        长事务合并为大事务
        长事务分解（不必要的请求摘除）
        应用侧保证一致性
脏页

优化
    尽量避免使用SELECT*，只查询需要的列。
    使用JOIN代替子查询，减少嵌套查询的层次。
    避免在WHERE子句中使用ILIKE‘%value%'，这会导致全表扫描。
    合理使用LIMIT子句，限制查询结果的数量。
    将表中不常用的字段或大型字段（如TEXT、BLOB）分离到单独的表中
    定期将不常用的日数据归档到历史表中，减少主表的数据量

Explain
    表的读取顺序
    SQL执行时查询操作类型
    可以使用哪些索引实际使用哪些索引
    每张表有多少行记录被扫描

    id 每个select都有一个对应的id号，并且是从1开始自增的
    select_type 查询语句执行的查询操作类型
    table 表名
    partitions 表分区情况
    type 查询所用的访问类型
        system > const > eq_ref > ref > fulltext > ref_or_null > range > index > ALL
        一般来说保证 range 级别，最好能达到 ref 级别。
        system：const类型的一种特殊场景，查询的表只有一行记录的情况，并且该表使用的存储引擎的统计数据是精确的
        const：基于主键或唯一索引查看一行，当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问转换成常量查询，效率高
        eq_ref：基于主键或唯一索引连接两个表，对于每个索引键值，只有一条匹配记录，被驱动表的类型为'eq_ref
        ref：基于非唯一索引连接两个表或通过二级索引列与常量进行等值匹配，可能会存在多条匹配记录
        range：使用非唯一索引l扫描部分索引l，比如使用索引获取某些范围区间的记录
        index：扫描整个索引就能拿到结果，一般是二级索引，这种查询一般为使用覆盖索引（需优化，缩小数据范围）
        NULL：MySQL在优化过程中分解语句就已经可以获取到结果，执行时甚至不用访问表或索引1。
    possible_keys 可能用到的索引
    key 实际查询用到的索引
    key_len 所使用到的索引长度 索引长度
    ref 使用到索引时，与索引进行等值匹配的列或者常量
        ref例：表示将哪个字段或常量和key列所使用的字段进行比较。
        当使用索引列等值查询时，与索引列进行等值匹配的对象信息。
    rows 预计扫描的行数（索引行数或者表记录行数）
        全表扫描时表示需要扫描表的行数估计值；索引扫描时表示扫描索引的行数估计值：值越小越好（不是结果集中的行数）
    filtered 表示符合查询条件的数据百分比
        表示符合查询条件的数据百分比。可以使用rows*filtered/100计算出与explain前一个表进行连接的行数。
    Extra SQL执行的额外信息