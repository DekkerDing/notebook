订单超时未支付
    轮询配置扫描过期标识的订单
    每隔n分钟，搜索订单表订单时间>15分钟的记录，将订单状态变更为取消

延时队列设计方案
    1. 定时任务轮询获取持久化任务

分布式微服务
    Raft 选举算法
        角色
            跟随者（Follower）
                普通群众，默默接收和来自领导者的消息，当领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。
            候选人（Candidate）
                候选人将向其他节点请求投票RPC消息，通知其他节点来投票，如果赢得了大多数投票选票，就晋升当领导者。
            领导者（Leader）
                霸道总裁，一切以我为准。处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者
                我还活着，你们不要”发起新的选举，不用找新领导来替代我。
        状态
            初始状态
                任期（Term）
                Raft算法实现了随机超时时间的特性，每个节点等待领导者节点心跳信息的超时时间间隔是随机的。
            发起投票

分布式全局唯一ID
    数据库 Redis 维护
    雪花算法
        时钟回拨

CAP
    C - Consistency 一致性
        一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态
        商品服务写入主数据库成功，则向从数据库查询新数据也成功
        商品服务写入主数据库失败，则向从数据库查询新数据也失败
        由于存在数据同步的过程，写操作的响应会有一定的延迟
        为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源
        如果请求数据同步失败的结点则会返回错误信息，一定不会返回日数据
    A - Availability 可用性
        可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误
        从数据库接收到数据查询的请求则立即能够响应数据查询结果
        从数据库不允许出现响应超时或响应错误
        所有请求都有响应，且不会出现响应超时或响应错误
    P-Partition tolerance 分区容忍性
        通常分布式系统的各各结点部署在不同的子网，这就是网络分区
        不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务，这叫分区容忍性
        主数据库向从数据库同步数据失败不影响读写操作
        其一个结点挂掉不影响另一个结点对外提供服务
        尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现松耦合
        添加从数据库结点，其中一个从结点挂掉其它从结点提供服务

BASE
    BASE是BasicallyAvailable(基本可用)
    Softstate(软状态)和Eventuallyconsistent(最终一致性)三个短语的缩写
    BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性
    当出现故障允许部分不可用但要保证核心功能可用
    允许数据在一段时间内是不一致的，但最终达到一致状态
    满足BASE理论的事务，我们称之为"柔性事务”

分布式事务
    模式
        AT
            阿里SEATA独有模式，通过生成反向SQL实现数据回滚，需要在数据库额外附加UNDO_LOG表
            存在数据不一致的中间状态
            所有服务与数据库必须要自己拥有管理权，因为要创建UNDOLOG表
            简单靠SEATA自己解析反向SQL并回滚
            高并发互联网应用，充许数据出现短时不一致，可通过对账程序或补录来保证最终一致性
            简单，靠SEATA自己解析反向SQL并回滚
            所有服务与数据库必须要自已拥有管理权，因为要创建UNDOLOG表
        TCC
            减少了2PC提交时对数据库资源的阻塞粒度
            第一阶段：Try阶段（排除一切为造成异常的业务)
                如检查业务的可行性
                预发操作如冻结库存
                插入一个无效订单初始数据 如订单状态初始为无效等下一阶段只需将订单改为有效即可
            第二阶段：Confirm阶段（直接提交数据库)
                操作业务
            第三阶段：Canel阶段（回滚数据库)
                阻塞回滚业务
                反向执行回滚业务
            TCC是Try-尝试、Cqnfirm-确认、Cancel-取消Try尝试阶段，对资源进行锁定
            Confirm确认阶段，对资源进行确认，完成操作Cancel取消阶段，对资源进行还原，取消操作
            存在数据不一致的中间状态
            复杂SEATATC只负责全局事务的提交与回滚指令具体的回滚处理全靠程序员自己实现
            所有服务与数据库必须要自己拥有管理权支持异构数据库，可以使用不同选型实现
            复杂，SEATATC只负责全局事务的提交与回滚指令，具体的回滚处理全靠程序员自己实现
            所有服务与数据库必须要自己拥有管理权支持异构数据库，可以使用不同选型实现
        SAGA
            Saga模式是SEATA提供的长事务解决方案
            在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者
            一阶段正向服务和二阶段补偿服务都由业务开发实现
            基于正向操作流程编排与反向操作流程编排完善整体事务中的一致性
            在当前架构引入状态机机制，类似于工作流无法保证隔离性
            需要与第三方交互时才会考虑，例如：调用支付宝支付接口->出库失败->调用支付宝退款接口
        XA
            简单基于数据库自带特性实现，无需改表
            强一致性
            金融行业并发量不大但数据很重要的项目
            简单，基于数据库自带特性实现，无需改表
            使用支持XA方案的关系型数据库（主流都支持）
    提交方案
        角色
            事务协调者
                协调各个分支事务 开启 提交 回滚 处理
            本地事务参与者
                开启事务+业务操作 (阻塞)
        2PC 二阶段提交
            依靠 数据库等自带的提交回滚机制实现事务特性
            事务预处理阶段
                准备阶段
                提交阶段
            问题
                某个服务因为网络原因无法收到协调者下达的提交命令，则未提交的数据就会被长时间阻塞，可能导致系统崩溃
        3PC 三阶段提交
            事务预处理阶段
                询问阶段 (判断本地事务应用当前是否处于可用状态)
                准备阶段
                预提交阶段 + 超时处理机制
                提交阶段
        最终一致性
            通讯询问阶段 (判断应用当前是否处于可用状态)
            MQ
                生产者
                    发送预备消息
                    发送提交消息
                消费者
                    确认消息
                        重试
                            业务重试处理
                            达到阀值补偿日志记录
                MQ 消息服务器
                    预备消息确定
                        反向执行
                            删除初始业务
                            删除预备消息
                    投递消息
        最大努力通知
            回调方法查询
                重载 不同的方法回调支持 主动查询数据
            通知队列
                基于 接收方(消费者) ACK 确认机制做应答
                区分不同时间段 数据库 数据持久化容器
                基于 定时任务 消费不同时间段容器数据 实现 延时消息实现最大努力通知

如何提高系统可用性
    关注点

幂等 与 锁
    redis是在幂等层中当第一次请求来了后会通过携带的标识 ID 把 ID 当作key去查询
    redis标识 ID 它也不能一直存在否则就有内存压力了在第一次请求的生成订单逻辑执行完了后要去redis里删除掉这个 ID 信息
    网关层 实现
    锁
        防止在多个人的并发请求下产生的数据问题
        如果请求没有获取到锁的话通常会尽量等待之前请求释放锁后
        再去获取锁争取继续执行请求 这时会进行程序阻塞
    幂等机制
        在同一个人的情况下只能第一个请求可以执行成功而后续重复请求那么就直接放弃执行请求立即结束

超时中心

SPM 用户行为采集

Outbound Gateway 出站网关

CQRS (数据中台)
    CQRS是命令和查询的职责分离
    数据集市 初步构建
    场景
        大数据量 操作与汇总 (聚合数据)
        写入
            用户操作(生成操作事件) -> kafka <-- 下游订阅消费 (汇总运算聚合) <-- 数据清洗 (归类不同数据聚合表)
        查询
            用户查询 -> 不同视角维度的数据(如 同比数据表 环比数据表)