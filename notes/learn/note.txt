IOC
    控制对象的创建
    控制对象内属性的赋值
    表示如果用Spring，那么Spring会负责来创建对象，以及给对象内的属性赋值，
    也就是如果用Spring，那么对象的控制权会转交给Spring

AOP

单例Bean和单例模式
    单例模式表示VM中某个类的对象只会存在唯一一个。
    而单例Bean并不表示JVM中只能存在唯一的某个类的Bean对象
    通过相同的Bean名称 在同一个Spring容器中 获取的Bean 对象是一个 单例Bean

Spring容器启动流程是怎样的
    1.在创建Spring容器，也就是启动Spring时：
    2.首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中
    3.然后筛选出非懒加载的单例BeanDefinition进行创建Bean
    对于多例Bean不需要在启动过程中去进行创建
    对于多例Bean会在每次获取Bean时利用BeanDefinition去创建
    4.利用BeanDefinition创建Bean就是Bean的创建生命周期
        这期间包括了合并BeanDefinition、
        推断构造方法、
        实例化、
        属性填充、
        初始化前、
        初始化、
        初始化后等步骤其中AOP就是发生在初始化后这一步骤中
    5.单例Bean创建完了之后，Spring会发布一个容器启动事件
    6.Spring启动结束
    7.  比如源码中会提供一些模板方法，让子类来实现，
        比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册
        Spring的扫描就是通过BenaFactoryPostProcessor来实现的
        依赖注入就是通过BeanPostProcessor来实现的
    8.在Spring启动过程中还会去处理 @Import 等注解
    Spring中的Bean创建的生命周期有哪些步骤
    Spring中一个Bean的创建大概分为以下几个步骤：
        1.推断构造方法
        2.实例化
        3.填充属性，也就是依赖注入
        4.处理Aware回调
        5.初始化前，处理@PostConstruct注解
        6.初始化，处理InitializingBean接口
        7.初始化后，进行AOP

Spring事务传播机制
    多个事务方法相互调用时，事务如何在这些方法间传播
    方法A是一个事务的方法，方法A执行过程中调用了方法B
    那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响
    同时方法A的事务对方法B的事务执行也有影响
    这种影响具体是什么就由两个方法所定义的事务传播类型所决定。
    1.REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务
    2.SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行
    3.MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。
    4.REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。
    5.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务
    6.NEVER：不使用事务，如果当前事务存在，则抛出异常
    7.NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）

Spring中的事务是如何实现的
    1.Spring事务底层是基于数据库事务和AOP机制的
    2.首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean
    3.当调用代理对象的方法时，会先判断该方法上是否加了@Transactional注解
    4.如果加了，那么则利用事务管理器创建一个数据库连接
    5.并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步
    6.然后执行当前方法，方法中会执行sql
    7.执行完当前方法后，如果没有出现异常就直接提交事务
    8.如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务
    9.Spring事务的隔离级别对应的就是数据库的隔离级别
    10.Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的
    11，Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，
    如果传播机制配置为需要新开一个事务
    那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql

Spring事务什么时候会失效？
    spring事务的原理是AOP
    进行了切面增强
    那么失效的根本原因是这个AOP不起作用了
    常见情况有如下几种
        1、发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而是UserService对象本身
            解决方法很简单，让那个this变成UserService的代理类即可
        2、方法不是public的：@Transactional只能用于public的方法上，否则事务不会失效
            如果要用在非public方法上，可以开启Aspect代理模式。
        3、数据库不支持事务
        4、没有被spring管理
        5、异常被吃掉，事务不会回滚（或者抛出的异常没有被定义，默认为RuntimeException)
        1．方法内的自调用：Spring事务是基于AOP的
            只要使用代理对象调用某个方法时Spring事务才能生效
            而在一个方法中调用使用this.xxO调用方法时
            this并不是代理对象
            所以会导致事务失效。
            a．解放办法1：
                把调用方法拆分到另外一个Bean中图买字
            b.解决办法2：
                自己注入自己
            c.解决办法3:
                AopContext.currentProxyO+@EnableAspectAutoProxy(exposeProxy=true)
        2.方法是private的：Spring事务会基于CGLIB来进行AOP
            而CGLIB会基于父子类来失效
            子类是代理类 父类是被代理类
            如果父类中的某个方法是private的，那么子类就没有办法重写它
            也就没有办法额外增加Spring事务的逻辑。
        3.方法是final的：原因和private是一样的，也是由于子类不能重写父类中的final的方法
        4.单独的线程调用方法：
            当Mybatis或JdbcTemplate执行SQL时
            会从ThreadLocal中去获取数据库连接对象
            如果开启事务的线程和执行SQL的线程是同一个
            那么就能拿到数据库连接对象
            如果不是同一个线程那就拿到不到数据库连接对象
            这样，Mybatis或JdbcTemplate就会自己去新建一个数据库连接用来执行SQL
            此数据库连接的autocommit为true，那么执行完SQL就会提交
            后续再抛异常也就不能再回滚之前已经提交了的SQL了。
        5.没加@Configuration注解：
            如果用SpringBoot基本没有这个问题，但是如果用的Spring，那么可能会有这个问题
            这个问题的原因其实也是由于Mybatis或JdbcTemplate会从ThreadLocal中去获取数据库连接
            但是ThreadLocal中存储的是一个MAP
            MAP的key为DataSource对象value为连接对象，而如果我们没有在AppConfig上添加@Configuration注解的话
            会导致MAP中存的DataSource对象和Mybatis和JdbcTemplate中的DataSource对象不相等
            从而也拿不到数据库连接
            导致自己去创建数据库连接了。
        6．异常被吃掉：如果Spring事务没有捕获到异常，那么也就不会回滚了，默认情况下Spring会捕获RuntimeException和Error。
        7.类没有被Spring管理
        8.数据库不支持事务

BeanFactory 与 FactoryBean
    BeanFactory
        是Spring框架的核心接口，是loC容器的顶层设计
        它定义了容器的基本功能，负责管理、装配和提供Bean。可以类比为一个大型工厂，负责生产和管理各种产品(Bean)
        提供Bean的生命周期管理
        实现依赖注入
        支持Bean的装配和延迟初始化
        ApplicationContext：更高级的容器，扩展了BeanFactory
        一个是容器，一个是产生Bean的工厂Bean
    FactoryBean
        是一个特殊的Bean，它是一个接口
        用于定制化Bean的创建逻辑
        当某些Bean的实例化过程复杂时，实现这个接口可以将复杂创建过程封装起来
        getobject：返回该工厂创建的对象实例
        getObjectTypeO：返回该工厂创建的对象类型
        isSingletonO：返回由该工厂创建的对象是否是单例
        解决特定Bean的复杂创建问题
        条件化Bean创建：根据条件创建不同实现的Bean

    https://www.bilibili.com/video/BV18C4y1A7EQ/?spm_id_from=333.337.search-card.all.click

    FactoryBean是一个接口
        它是一个Bean
        FactoryBean并不是一个简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean
        它最大的一个作用是：可以让我们自定义Bean的创建过程。

    BeanFactory (策略工厂模式)
        以Factory结尾，说明它是一个工厂类
        它是一个负责生产和管理bean的工厂
        在Spring中，BeanFactory是IOC容器的核心接口
        它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖

Spring 设计模式
    工厂模式
        BeanFactory FactoryBean ProxyFactory
    原型模式
        PrototypeTargetSource
        PrototypeAspectinstanceFactory
    单例模式
        SingletonTargetSource
        DefaultBeanNameGenerator
        SimpleAutowireCandlidateResolver
        AnnotationAwareOrderComparator
    构造器模式
        BeanDefinitionBuilder
        StringBuilder
        BeanFactoryAspectUAdvisorsBuilder
    适配器模式
        AdvisorAdapter
        ApplicationListenerMethodAdapter
    访问者模式
        PropertyAccessor
        MessageSourceAccessor
    装饰者模式
        BeanWrapper
        HttpRequestWrapper
    策略模式
        InstantiationStrategy BeanNameGenerator
    模板方法
        AbstractApplicationContext
    责任链模式
        DefaultAdvisorChainFactory
        QualifierAnnotationAutowireCandidateResolver
    观察者模式
        ApplicationListener
        AdvisedSupportListener

Spring中Bean是线程安全的吗
    Spring本身并没有针对Bean做线程安全的处理
        1.如果Bean是无状态的，那么Bean则是线程安全的
        2.如果Bean是有状态的，那么Bean则不是线程安全的
        另外，Bean是不是线程安全，跟Bean的作用域没有关系
            Bean的作用域只是表示Bean的生命周期范围
                对于任何生命周期的Bean都是一个对象
                这个对象是不是线程安全的还是得看这个Bean对象本身

Spring 循环依赖
    互相依赖
    间接依赖
    自我依赖
        一级缓存
            完全初始化好的Bean
        二级缓存
            原始的Bean对象 还没有进行赋值没有被依赖注入
        三级缓存
            Bean工厂对象生成原始Bean对象放入二级缓存中
    多实例的Setter注入导致的循环依赖，需要把Bean改成单例。
    构造器注入导致的循环依赖，可以通过@Lazy注解
    DependsOn导致的循环依赖，找到注解循环依赖的地方，迫使它不循环依赖。
    单例的代理对象Setter注入导致的循环依赖
        可以使用@Lazy注解
        或者使用@DependsOn注解指定加载先后关系

过滤器 拦截器
    过滤器
        接收到请求之后但是在Servlet被调用之前运行的
        只能对reguest和response进行操作
    拦截器
        则是在Servlet被调用之后但是在响应被发送到客户端之前来运行的
        request、responses handler、 modelAndView.
        exception

创建对象
    加载
        londBeanDefinitions (加载 Bean 定义)
    查询缓存
    创建对象初始信息 (Bean 实例化) create Bean
        类 的 Type 查找 / 类名称查找
        工厂方法模板(获取定义对象信息类信息) + 反射
        初始对象信息 放入 三级缓存 beanDefinitionMap
    填充属性 (属性赋值)
        解析自动装配
            ByName
            ByType
            Constrator
            @Autowired
        就要执行aetObiect方法了
            对象放入二级缓存
    初始化 initializeBean
        回调 前后置 处理器
            BeanNameAware
            invokeAwareMethods
            BeanFactoryAware
            BeanClasLoaderAware
            ApplicationEventPublisherAware
            ResourceLoaderAware
            ApplicationContextAware
        AOP 动态代理的代理类,基于代理类模板生成实例化代理对象
        @Postconstruct
        将一个完整对象放入一级缓存

事务
    步骤
        获取数据源
        获取事务
            先从ThreadLocal中获取数据源的连接如果不为空那就说明之前有方法创建事务了
            用ThreadLocal可以实现在同一个线程下事务的共用
        开启事务
            从数据源中获取到连接放到事务集成树对象里修改为手动提交标记激活事务
            key为数据源 value为连接对象
            维护这个资源对象就在事务管理器中状态
        准备事务
            填充事务管理器设置事务隔离级别事务名字
        提交事务
            判断 维护在务管理器中的事务回滚标准位 从 当前 ThreadLocal中通过Key值获取数据连接对象发送回滚命令
            如正常操作 这上述步骤直接手动提交
@Resource / @Autowire
    @Resource
        resource是我们JavaEE提供的
        根据名称去寻找 如果名称不存在 才会根据类型去查找
    @Autowire
        它是我们spring框架里面去提供的
        默认根据类型查找 类型有多个实现再根据名称去查找