多线程
    有了多线程我们就可以让程序同时做多件事情提高效率
    只要你想让多个事情同时运行就需要用到多线程
    比如：软件中的耗时操作、所有的聊天软件、所有的服务器
并发
    在同一时刻，有多个指令在单个CPU上交替执行
并行
    在同一时刻，有多个指令在多个CPU上同时执行
协程
    1.协程可以在一个线程内部创建多个协程，这些协程之间可以共享同一个线程的资源
    2.协程是在同一个进程内部运行的，不需要操作系统的介入，可以在用户空间内实现协作式多任务处理。
        因此协程的创建和销毁开销很小，可以更高效地利用系统资源。
    通俗角度：通俗地说，如果线程是饭店的饭桌协程就是座椅。

线程创建
    继承Thread类的方式进行实现
    实现Runnable接口的方式进行实现
    利用Callable接口和Future接口方式实现
    setDaemon() 设置为守护线程
        当其他的非守护线程执行完毕之后，守护线程会陆续结束
    yield() 出让线程/礼让线程
        yield方法并不能保证线程一定会让出CPU资源，它只是一个提示，告诉调度器当前线程愿意让出CPU资源。
        具体是否让出CPU资源，还是由调度器决定。
    join() 插入线程/插队线程
        等待这个线程执行结束
        表示把设置的这个线程，插入到当前线程之前
        当前： 看所执行的代码是运行在哪个线程上面的

synchronized:
    锁对象
        同步代码块
            基于 类 静态变量方式 static Object obj = new Object();
            this： 指的是当前执行代码的线程或者对象 (不推荐使用 this 因为它不是维护这同一个锁资源对象 无法实现锁机制)
            类名.class 指当前类 (推荐使用 能够基于JVM虚拟机 类加载特性 确保锁对象的唯一性)
        同步方法
            同步方法是锁住方法里面所有的代码
            锁对象不能自己指定
                非静态的方式  他的锁对象是 this 指的是当前执行代码的线程或者对象
                静态的方式 当前类的字节码文件对象 类名.class
    锁膨胀 锁升级 锁降级
        JDK 1.6
            Synchronized在1.6版本之前性能较差
            是通过重量级锁的方式来实现线程之间的一个锁的竞争的
            依赖 操作系统层面的MutexLock
            在并发不严重的情况下
            因为Synchronized依然对象上锁
            每个对象需要维护一个管程对象，管程对象需要维护一个Mutex互斥量对象。
            Mutex是由操作系统内部的pthread线程库维护的。
            上锁需要通过JVM从用户态切换到内核态来调用底层操作系统的指令，这样操作的性能较差。
            JDK1.6版本为了弥补Synchronized的性能缺陷，设计了Synchronized锁的膨胀升级。
            也就是根据当前线程的竞争激烈程度，设计了不同效果的锁。
        锁状态
            无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
        偏向锁
            锁默认情况下 开启了偏向锁延迟
                偏向锁升级为轻量级锁时会涉及到偏向锁撤销
                需要等到一个安全点（STW），才可以做偏向锁撤销
                在明知道有并发情况，就可以选择不开启偏向锁，或者是设置偏向锁延迟开启

            因为JVM在启动时，需要加载大量的.class文件到内存中
            这个操作会涉及到synchronized的使用，为了避免出现偏向锁撤销操作
            JVM启动初期，有一个延迟5s开启偏向锁的操作

            如果正常开启偏向锁了，那么不会出现无锁状态，对象会直接变为匿名偏向
            关闭偏向锁功能
                使用-XX:-UseBiasedLocking参数关闭偏向锁，此时默认进入轻量级锁
            多个线程竞争偏向锁
                偏向锁状态下，由于别的线程尝试竞争偏向锁
                并且CAS更新
                MarkWord中线程ID失败
                此时发生【偏向锁->轻量级锁】升级；
        轻量级锁
            加锁
                1.
                    JVM会在当前线程的栈帧中建立一个名为锁记录（LockRecord）的空间
                    用于存储锁对象目前的MarkWord的拷贝（官方称为DisplacedMarkWord）
                    若一个线程获得锁时发现是轻量级锁，它会将对象的MarkWord复制到栈帧中的锁记录Lock Record中（Displaced MarkWord里面）；
                2.
                    线程尝试利用CAS操作将对象的MarkWord更新为指向Lock Record的指针
                    如果成功表示当前线程竞争到锁
                    则将锁标志位变成00
                    执行同步操作；
                3.
                    如果失败，表示MarkWord已经被替换成了其他线程的锁记录
                    说明在与其他线程抢占竞争锁
                    当前线程就尝试使用自旋来获取锁；
            锁释放
                轻量级锁的释放也是通过CAS操作来进行的，当前线程使用CAS操作将DisplacedMarkWord的内存复制回锁对象的MarkWord 中
                如果CAS操作替换成功
                则说明释放锁成功；
                如果CAS自旋多次还是替换失败的话，说明有其他线程尝试获取该锁
                则需要将轻量级锁膨胀升级为重量级锁；
            优点
                在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗；
            缺点
                如果长时间自旋后还没竞争到锁，将会过度耗费CPU，即 CPU空转；




等待/唤醒
    wait() 当前线程等待，直到被其他线程唤醒
    notify() 随机唤醒单个线程
    notifyAll() 唤醒所有线程
    阻塞队列
        ArrayBlockingQueue 底层是数组 有界
        LinkedBlockingQueue 底层是链表，无界但不是真正的无界最大为int的最大值

线程状态
    新建
        创建线程对象  Thread thread = new Thread()
    就绪
        等待 CPU 分配时间片 start()
    死亡
        run 方法执行完毕
    阻塞
        锁 阻塞
        程序操作运行阻塞
    等待/唤醒
        wait()
        notify()
        notifyAll()
    计时等待
        sleep()

线程池
    任务拒绝策略
        ThreadPoolExecutor.AbortPolicy
            默认策略： 丢弃任务并抛出RejectedExecutionException异常
        ThreadPoolExecutor.DiscardPolicy
            丢弃任务，但是不抛出异常这是不推荐的做法
        ThreadPoolExecutor.DiscardoldestPolicy
            抛弃队列中等待最久的任务然后把当前任务加入队列中
        ThreadPoolExecutor.CallerRunsPolicy
            调用任务的run()方法绕过线程池直接执行
    工作流程
        1. 当核心线程满时，再提交任务就会排队
        2. 当核心线程满，队列满时，会 查看设置的最大线程数 创建临时线程(基于存活时间 并 进行资源管理)
        3. 当核心线程满，队列满，临时线程满时，会触发任务拒绝策略
    execute/submit
        参数
            execute Runnable.run
            submit callable
        返回值
            execute void
            submit Future

CompletableFuture
    Completionstage 提供了更高级的功能和更好的可组合性。
    它是Java8中引l入的，作为java.util.con current 包的一部分。
    Completionstage 允许你以声明式的方式组合和链接异步操作，而不需要显式地处理回调函数。
    CompletableFuture的内部使用了基于ForkJoinPool的线程池，这种线程池可以高效地调度和执行任务。
    CompletableFuture的非阻塞特性得益于其对任务完成的监听机制。
    当任务完成时，它会遍历所有注册的回调函数，并在合适的线程中执行这些回调。
    通过这种机制，CompletableFuture能够在任务完成后及时返回结果或触发后续处理逻辑而不会阻塞主线程的执行。
    supplyAsync(Supplier<T> supplier)
        异步执行一个Supplier函数，并返回一个表示其结果的 CompletableFuture。
    runAsync(Runnable runnable)
        异步执行一个Runnable，不返回任何结果。
    thenAsync(Function<T, U> function)
        会利用CompletableFuture中公共的ForkJoinPool来执行任务
    thenApply(Function<T, U> function)
        当前Future 完成后，对其结果应用给定函数，并返回新的 CompletableFuture 有入参，有返回值
    thenAccept(consumer<T> action)
        当前 Future 完成后，对结果应用给定的 Consumer，不返回新值 有入参，无返回值
    thenRun(Runnable action)
        当前 Future 完成后，执行给定的 Runnable，不关心当前Future 的结果 无入参，无返回值
    thenCompose(Function<T, CompletableFuture< U>> function)
        当前Future 完成后，将结果传递给另一个 CompletableFuture 作为输入 有入参，有返回值，返回值类型只能是CompletionStage
        按顺序执行两个并行任务
    thenCombine CompletionStage<?extends U>other,BiFunction<?super T,?super U,?extendsV>fn
        第一个参数为CompletionStage
        第二个参数为具体要执行的任务，认为类型为BiFunction，有两个入参，一个返回值
        整合两个并行执行的任务结果
    runAfterEither
        两个任务中任意一个完成了，就执行回调
    runAfterBoth
        两个任务都完成了，才执行回调
    handle(BiFunction<T, Throwable, U> fn)
        处理当前Future 的结果或异常，并允许返回一个新结果。
    exceptionally(Function<Throwable, U> fn)
        指定当当前Future遇到异常时应采取的操作。
    complete(U value)
        显式地完成当前Future，设置其结果为给定值 直接让任务完成
    completeExceptionally(Throwable ex)
        显式地完成当前Future，设置其异常为给定异常。
    isDone()
        判断当前Future是否已完成。
    isCompletedExceptionally()
        判断当前Future是否因异常而完成。
    get()
        阻塞并等待当前Future 完成，然后返回结果。如果完成时出现异常，则抛出异常。
    get(long timeout, TimeUnit unit)
        在指定时间内阻塞并等待当前Future 完成，然后返回结果。如果超时或完成时出现异常，则抛出异常。
    T getNow(T valuelfAbsent)
        立即获取结果，如果任务还没完成，则返回valuelfAbsent
    whenComplete
        入参为BiConsumer<？superT,？superThrowable> action
        任务正常结束第一个参数传入的是结果
        任务异常结束第二个参数传入的是异常 异常类型是CompletionException
        没有返回值
    exceptionally
        入参为Function<Throwable，？extendsT> fn
        入参为异常 异常类型是CompletionException
        可以返回其他值
        如果任务没有出现异常则不会执行
    cancel
        如果任务还没开始，或正在执行，则能取消，设置取消标记为 true
        如果任务已经完成，则设置取消标记为 false
    allOf
        所有任务都执行完后才执行下一个任务
    anyOf
        任意一个任务执行完就可以执行下一个任务了

线程安全指的是
    我们写的某段代码在多个线程同时执行这段代码时，不会产生混乱
    依然能够得到正常的结果
    比如i++，初始化值为0，那么两个线程来同时执行这行代码，如果代码是线程安全的，那么最终的结果应该就是一个线程的结果为1
    一个线程的结果为2，如果出现了两个线程的结果都为1
    则表示这段代码是线程不安全的
    所以线程安全，主要指的是一段代码在多个线程同时执行的情况下，能否得到正确的结果
    线程安全的集合
        Synchronized
            Hashtable <-> HashMap
            Vector <-> List
        CAS Concurrent类型的容器
            弱一致性
            遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的
            求大小弱一致性，size操作未必是100%准确
            读取弱一致性
            ConcurrentHashMap


        Blocking

        CopyOn Write



ThreadLocal
    ThreadLocal也就是线程本地变量。
    如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝
    多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量
    从而起到线程隔离的作用，避免了线程安全问题
    ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据
    ThreadLocal底层是通过ThreadLocalMap来实现的
    每个Thread对象（注意不是ThreadLocal对象）中都存在一个 ThreadLocalMap
    Map的key为ThreadLocal对象，Map的value为需要缓存的值
    样例
        Map<ThreadLocal, Object> ThreadLocalMap = new HashMap();
    ThreadLocal内存泄露
        如果在线程池中使用ThreadLocal会造成内存泄漏
        因为当ThreadLocal对象使用完之后，应该要把设置的key，value，也就是Entry对象进行回收，但线程池中的线程不会回收
        而线程对象是通过强引I用指向ThreadLocalMap
        ThreadLocalMap也是通过 强引用 指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏。
        解决办法是在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法
        手动清除Entry对象。
InheritableThreadLocal
    InheritableThreadLocal 是 ThreadLocal 子类
    解决 父子线程上 数据共享 (但在程序 运行中 共享值发生改变后面获取是无法获取到新的变更后的值的)
    TransmittableThreadLocal
        可实现 程序运行时共享数据改变实时刷新

as-if-serial happens-before
    as-if-serial语义的意思是
        不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。
        编译器、runtime和处理器都必须遵守as-if-serial语义。
        为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序
        因为这种重排序会改变执行结果。
        但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。
    happens-before原则
        只靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦
        幸运的是，从JDK5 开始，Java使用新的JSR-133内存模型
        提供了happens-before原则来辅助保证程序执行的原子性、可见性以及有序性的问题
        它是判断数据是否存在竞争、线程是否安全的依据
        1.程序顺序原则：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。
        2.锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
        3.volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
        4.线程启动规则：线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见
        5.传递性：A先于B，B先于C那么A必然先于C
        6.线程终止规则：线程的所有操作先于线程的终结，Threadjoin（)方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。
        7.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted（）方法检测线程是否中断
        8.对象终结规则：对象的构造函数执行，结束先于finalize（）方法
双重检测锁DCL对象半初始化问题
    JVM 字节码加载成对象过程中 会经历 分配堆空间内存 -> 初始化 零 值 -> 加载对象头初始化对象头信息 -> 更具以上信息 执行 init() 方法实现对象创建
    一旦没有 volatile 修饰 造成指令重排序 在未进行 零值初始化时 提前执行了 init()方法 使用判断该对象会有 空指针问题

原子类
    原子类的作用和锁类似，是为了保证并发情况下的线程安全。不过原子类相对于锁有一点的优势
    不可分割 一个操作是不可中断的，即便是多线程的情况下也可以保证
    粒度更细：
        原子变量可以把竞争范围缩小到变量级别
        这是我们可以获得的最细的粒度的情况了，通常锁的粒度都要大于原子变量的粒度
    效率更高：
        通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况

StampedLock
    该类自JDK8加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用
    加解读锁
        long stamp =lock.readLock();
        lock.unlockRead(stamp);
        乐观读，StampedLock支持tryOptimisticRead（）方法（乐观读）
        读取完毕后需要做一次戳校验如果校验通过
        表示这期间确实没有写操作
        数据可以安全使用
        如果校验没通过需要重新获取读锁保证数据安全

Semaphore
    信号量，用来限制能同时访问共享资源的线程上限

CountdownLatch
    用来进行线程同步协作，等待所有线程完成倒计时
    其中构造参数用来初始化等待计数值
    await()用来等待计数归零，countDown()用来让计数减一

CyclicBarrier
    可重入
    循环栅栏，用来进行线程协作
    等待线程满足某个计数。构造时设置『计数个数』
    每个线程执行到某个需要“同步"的时刻调用awaitO方法进行等待
    当等待的线程数满足『计数个数』时，继续执行